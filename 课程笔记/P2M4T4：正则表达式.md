## 
正则表达式是对字符串操作的一种逻辑公式。  
它可以做到：
- 给定的字符串是否符合正则表达式的过滤逻辑（匹配）
- 可以通过正则表达式，从字符串中获取我们想要的特定部分（提取）
- 强大的字符串替换能力（替换）

## 创建正则的方法#2
在 JavaScript 中，正则表达式也是对象，是一种索引类型。

- 使用正则表达式字面量【常用】  
    `var reg = /abc/;`
- 调用 RegExp 对象的构造函数  
    `var reg = new RegExp('abc');`
    
## 常用方法#3~5
字符串的方法：
- split()  
    根据匹配字符串精确切割父字符串  
    例如，`str.split('a');` 将得到以单个字母a分割的数组。  
    
    正则实现以连续的相同字符串分割：  
    `str.split(/a+/);` + 表示一个或多个连续 
- search()  
    寻找子字符串在父字符串中位置，返回第一次出现的位置下标。  
    
    正则实现模糊匹配：  
    `str.search(/o\s+o);` 寻找以 o 开始和结束，并且中间是空白的字符串
- match()  
    在父字符串中寻找匹配字符串，返回寻找结果。  

    正则实现返回所有：  
    `str.match(/b+/g);` 全局修饰符 g 表示会在找到所有匹配字符串后结束 
- replace(a,b)  
    参数：  
    - a：规定子字符串或要替换目标的正则表达式    
    - b：一个字符串值，作为替换文本；或一个生成替换文本的函数  
        函数写法：`function (match,){}` 其中参数match为固定要求  
        使用例子另见【#13】

正则表达式的方法：
- exec()
    在实参中查找字符串，返回位置下标，只能找到第一个匹配的结果  
    `/abc/.exec('abcdefabc');`
- test()
    判断实参中是否包含子字符串，返回布尔值  
    e.g. `/\s/.test('a bc');` 判断字符串是否包含空格

## 正则表达式的组成#6
正则表达式中有普通字符和特殊字符（也称元字符 metacharacters）。

特殊字符需要使用转移符号 `\` 反斜杠。  
在 JavaScript 中，特殊字符主要有：( ) [ ] { } \ ^ $ | ? * +  
还有其他的预定义特殊字符：  
\t 制表符  
\n 回车符  
\f 换页符  
\b 空格

> 在 js 的字符串中包含换行，需要使用小引号 ` 包裹。

## 正则表达式的术语
### 字符集#7
`[]` 整体代表一个字符，里面包含多个字符，任意符合其中一个都算满足  
- 简单类: 正则的多个字符对应一个字符，我们可以用 [] 把它们括起来，让 [] 这个整体对应一个字符。`[abc]`  
    e.g. `o[usb]t`——obt、ost、out
- 范围类: 有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以在中间加了个横线。`[a-z]`、`[0-9]`、`[A-Z]`  
    e.g. `id[0-9]`——id0、id5
- 负向类: [] 前面加个元字符进行取反，表示匹配不能为括号里面的字符。`[^a]`  
    e.g. `o[^0-9]t`——oat、o?t、o t
- 组合类: 允许用中括号匹配不同类型的单个字符。`[0-9a-b]`、`[^0-9A-Z]`  
    e.g. `o[0-9a-b]t`——oat、o?t
### 修饰符#8
- g  
    修饰符用于执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）
    
- i  
    修饰符用于执行对大小写不敏感的匹配。
    
### 边界#9
- ^  
    开头，表示后面的正则表达式的匹配结果必须出现在字符串开始
    
- $  
    结尾，表示后面的正则表达式的匹配结果必须出现在字符串结尾
    
应用中，经常将 ^ 和 $ 同时应用，限制开头和结尾
### 预定义类#10
以下是等价的
- `.` 非回车非换行的任意字符 `[^\n\r]`
- `\d` 数字字符 `[0-9]`
- `\D` 非数字字符 `^[0-9]`
- `\s` 空白字符 `[\t\n\x0B\f\r]`
- `\S` 非空白字符 `[^\t\n\x0B\f\r]`
- `\w` 单词字符（所有的字母、数字、下划线） `[a-zA-Z_0-9]`
- `\W` 非单词字符 `[a-zA-Z0-9]`

### 量词#11
跟在正则表达式后
- `{n}` 硬性量词，对应零次或者n次
- `{n,m}` 软性量词，至少出现n次但不超过m次（中间不能有空格）
- `{n,}` 软性量词，至少出现n次（+的升级版）
- `?` 软性量词，出现零次或一次，等价于`{0,1}`
- `*` 软性量词，出现零次或多次(任意次)，等价于`{0,}`
- `+` 软性量词，出现一次或多次（至少一次），等价于`{1,}`

### 分组#12
`[]` 划定了范围，`{}` 表示了次数，`()` 用来分组

### 或操作符
| 或操作符的优先级极低，需要注意使用分组  
e.g.  
`/^ab|cd$/` 表示以 ab 开头或以 cd 结尾的  
`/^(ab|cd)$/` 表示以 ab 或 cd 开头并结尾的

## 分组的反向引用#13
反向引用标识是对正则表达式中的匹配组捕获的子字符串进行编号，从1开始计数。  
在表达式内反向引用：`\n` ；在表达式外反向引用：`$n`  
e.g.  
`/(bye)\1/.test('byebye');` 结果为 true。寻找
`/^([a-z]{3})\1$/.test('byebye');` 结果为。
**【不清不楚的】**

e.g.
```js
'123*456'.replace(/(\d{3})\*(\d{3})/, function (match),$1,$2){
    return $2 + '*' +$1;
})
```
输出结果：456*123（调换顺序）

## 中文字符#14
[\u4e00-\u9fa5]